<!DOCTYPE html>
<html lang="zh-CN">
<head>

  <meta charset="UTF-8" />
  <title>ç”Ÿæ—¥è›‹ç³•</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      color: #fff;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
    
    #title {
      position: fixed;
      top: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
      z-index: 10;
      padding: 0 20px;
      pointer-events: none;
    }
    
    #instructions {
      position: fixed;
      top: 70px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: clamp(0.8rem, 2vw, 1rem);
      color: rgba(255, 255, 255, 0.85);
      z-index: 10;
      padding: 0 20px;
      pointer-events: none;
    }
    
    #mobileInstructions {
      position: fixed;
      top: 100px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: clamp(0.7rem, 2vw, 0.9rem);
      color: rgba(255, 255, 255, 0.7);
      z-index: 10;
      padding: 0 20px;
      pointer-events: none;
    }
    
    #controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 10;
      padding: 0 20px;
      flex-wrap: wrap;
    }
    
    .control-btn {
      padding: 12px 25px;
      font-size: 16px;
      border-radius: 50px;
      border: none;
      background: linear-gradient(135deg, #4facfe, #00f2fe);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
      font-weight: bold;
      min-width: 140px;
      -webkit-tap-highlight-color: transparent;
    }
    
    .control-btn:hover, .control-btn:active {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
    }
    
    #birthdayMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(2rem, 5vw, 3.5rem);
      color: #ffd700;
      text-align: center;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      transition: opacity 1s ease;
      width: 90%;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      line-height: 1.3;
    }
    
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #ffd700;
      z-index: 100;
    }
    
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
    
    .floating-text {
      position: fixed;
      top: 140px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      z-index: 10;
      pointer-events: none;
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
    }
    
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      pointer-events: none;
      z-index: 5;
    }
    
    .mic-status {
      position: fixed;
      bottom: 100px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: #4CAF50;
      z-index: 10;
      opacity: 0.8;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .mic-status.blowing {
      color: #ff6b6b;
      animation: pulse 0.5s infinite alternate;
    }
    
    @keyframes pulse {
      from { opacity: 0.6; }
      to { opacity: 1; }
    }
    
    .touch-controls {
    display: none !important;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
    }
  
    .touch-joystick {
      position: absolute;
      width: 120px;
      height: 120px;
      bottom: 100px;
      left: 30px;
      pointer-events: auto;
    }
    
    .touch-joystick-base {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.3);
      position: absolute;
    }
    
    .touch-joystick-handle {
      width: 50px;
      height: 50px;
      background: rgba(255, 215, 0, 0.7);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .touch-zoom {
      position: absolute;
      width: 60px;
      height: 120px;
      bottom: 100px;
      right: 30px;
      pointer-events: auto;
    }
    
    .zoom-btn {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      margin-bottom: 10px;
      -webkit-tap-highlight-color: transparent;
    }
    
    .permission-prompt {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
      text-align: center;
    }
    
    .permission-content {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 20px;
      max-width: 400px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .permission-content h2 {
      color: #ffd700;
      margin-bottom: 15px;
    }
    
    .permission-content p {
      margin-bottom: 20px;
      line-height: 1.5;
    }
    
    .permission-btn {
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 50px;
      border: none;
      background: linear-gradient(135deg, #4CAF50, #8BC34A);
      color: white;
      cursor: pointer;
      margin: 5px;
      width: 100%;
      -webkit-tap-highlight-color: transparent;
    }
    
    .stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .star {
      position: absolute;
      background-color: white;
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    .auto-hide {
      animation: fadeOut 5s forwards 3s;
    }
    
    @keyframes fadeOut {
      to { opacity: 0; }
    }
    
    @media (max-width: 768px) {
      .control-btn {
        padding: 10px 20px;
        font-size: 14px;
        min-width: 120px;
      }
      
      #title {
        font-size: 1.5rem;
        top: 10px;
      }
      
      #instructions {
        font-size: 0.8rem;
        top: 50px;
      }
      
      #mobileInstructions {
        font-size: 0.7rem;
        top: 80px;
      }
      
      .floating-text {
        top: 120px;
        font-size: 0.9rem;
      }
      
      .touch-joystick {
        width: 100px;
        height: 100px;
        left: 20px;
        bottom: 90px;
      }
      
      .touch-zoom {
        right: 20px;
        bottom: 90px;
      }
      
      .zoom-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .mic-status {
        bottom: 80px;
        font-size: 0.8rem;
      }
    }
    
    @media (max-width: 480px) {
      .control-btn {
        padding: 8px 15px;
        font-size: 12px;
        min-width: 100px;
      }
      
      .floating-text {
        top: 110px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>

<audio id="blowSound" preload="auto" style="display: none;">
  <!-- è¿™é‡Œéœ€è¦æ›¿æ¢ä¸ºæ‚¨å®é™…çš„éŸ³æ•ˆæ–‡ä»¶è·¯å¾„ -->
<source src="blow-sound.mp3" type="audio/mpeg">
<source src="blow-sound.ogg" type="audio/ogg">
</audio>

<div class="stars" id="stars"></div>
<div id="loading" class="loading">ğŸ‚ åŠ è½½ä¸­...</div>

<div id="permissionPrompt" class="permission-prompt" style="display: none;">
  <div class="permission-content">
    <h2>ğŸ‚  ç”Ÿæ—¥å¿«ä¹ï¼ ğŸ‚</h2>
    <p>è®¸ä¸ªæ„¿ï¼Œå¯¹ç€éº¦å…‹é£å¹æ°”æ¥å¹ç­èœ¡çƒ›å§ï¼</p>
    <p>è¯·å…è®¸éº¦å…‹é£è®¿é—®ä»¥ä½¿ç”¨å¹æ°”åŠŸèƒ½ã€‚</p>
    <button id="allowMic" class="permission-btn">ğŸ¤ å…è®¸éº¦å…‹é£è®¿é—®</button>
    <p style="font-size: 0.8rem; margin-top: 10px; opacity: 0.7;">ï¼ˆä¸å¯ç”¨éº¦å…‹é£ä¹Ÿå¯ä»¥è§‚çœ‹è›‹ç³•ï¼‰</p>
  </div>
</div>

<h1 id="title">ğŸ‚ ç”Ÿæ—¥å¿«ä¹ ğŸ‚</h1>
<div class="floating-text">è®¸ä¸ªæ„¿ï¼Œå¹ç­èœ¡çƒ›å§ï¼</div>
<div id="birthdayMessage">ğŸ‰ ç”Ÿæ—¥å¿«ä¹ï¼ ğŸ‰</div>

<div class="mic-status" id="micStatus">ğŸ¤ æ­£åœ¨æ£€æµ‹å¹æ°”...</div>

<div id="controls">
  <button id="relightBtn" class="control-btn">ğŸ”¥ é‡æ–°ç‚¹ç‡ƒ</button>
</div>

<div class="touch-controls">
  <div class="touch-joystick" id="joystick" style="display: none;">
    <div class="touch-joystick-base"></div>
    <div class="touch-joystick-handle"></div>
  </div>
  <div class="touch-zoom" id="touchZoom" style="display: none;">
    <div class="zoom-btn" id="zoomIn">+</div>
    <div class="zoom-btn" id="zoomOut">-</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
  createStars();
  
  // åˆå§‹åŒ–å˜é‡
  let scene, camera, renderer;
  let cakeGroup, flames = [];
  let confettiActive = false;
  let confettiParticles = [];
  let birthdayTextMeshes = [];
  let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  let audioContext, analyser, microphone, dataArray, isMicActive = false;
  let blowIntensity = 0;
  let lastBlowTime = 0;
  let isTouchJoystickActive = false;
  let joystickStartPos = { x: 0, y: 0 };
  let joystickCurrentPos = { x: 0, y: 0 };
  let cakeRotationSpeed = { x: 0, y: 0 };
  let micPermissionRequested = false;
  let smokeParticles = [];
  let flameTextures = [];
  let clock = new THREE.Clock();
  let originalCameraPosition = null;
  let originalCameraRotation = null;
  
  // åˆå§‹åŒ–
  function init() {
    try {
      // 1. åˆ›å»ºåœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      scene.fog = new THREE.Fog(0x0a0a1a, 10, 30);
      
      // 2. åˆ›å»ºç›¸æœº
      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 8, 20);
      originalCameraPosition = camera.position.clone();
      originalCameraRotation = camera.rotation.clone();
      
      // 3. åˆ›å»ºæ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // 4. åˆ›å»ºç«ç„°çº¹ç†
      createFlameTextures();
      
      // 5. æ·»åŠ å…‰ç…§
      addLights();
      
      // 6. åˆ›å»ºè›‹ç³•
      createCake();
      
      // 7. éšè—åŠ è½½æç¤º
      document.getElementById('loading').style.display = 'none';
      
      // 8. å¼€å§‹åŠ¨ç”»
      animate();
      
      // 9. æ·»åŠ äº‹ä»¶ç›‘å¬
      setupEventListeners();
      
      // 10. è‡ªåŠ¨è¯·æ±‚éº¦å…‹é£æƒé™
      setTimeout(() => {
        requestMicrophonePermission();
      }, 1500);
      
    } catch (error) {
      console.error("åˆå§‹åŒ–é”™è¯¯:", error);
      document.getElementById('loading').textContent = 'åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢';
    }
  }
  
  // åˆ›å»ºç«ç„°çº¹ç†
  function createFlameTextures() {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    // åˆ›å»ºå¤šä¸ªç«ç„°çº¹ç†å¸§
    for (let i = 0; i < 4; i++) {
      ctx.clearRect(0, 0, 64, 64);
      
      // åˆ›å»ºå¾„å‘æ¸å˜
      const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      
      // æ ¹æ®å¸§æ•°åˆ›å»ºä¸åŒçš„ç«ç„°é¢œè‰²
      if (i === 0) {
        gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
        gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
      } else if (i === 1) {
        gradient.addColorStop(0, 'rgba(255, 240, 180, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 180, 80, 0.8)');
        gradient.addColorStop(0.6, 'rgba(255, 80, 0, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 30, 0, 0)');
      } else if (i === 2) {
        gradient.addColorStop(0, 'rgba(255, 230, 160, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 160, 60, 0.8)');
        gradient.addColorStop(0.6, 'rgba(255, 60, 0, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 20, 0, 0)');
      } else {
        gradient.addColorStop(0, 'rgba(255, 220, 140, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 140, 40, 0.8)');
        gradient.addColorStop(0.6, 'rgba(255, 40, 0, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 10, 0, 0)');
      }
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);
      
      // æ·»åŠ ä¸€äº›å™ªç‚¹
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      for (let j = 0; j < 20; j++) {
        const x = Math.random() * 64;
        const y = Math.random() * 64;
        const radius = Math.random() * 3;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      flameTextures.push(texture);
    }
  }
  
  // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
  function createStars() {
    const starsContainer = document.getElementById('stars');
    const starCount = 150;
    
    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      
      const size = Math.random() * 3 + 1;
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 100 + '%';
      
      star.style.animationDelay = Math.random() * 3 + 's';
      star.style.opacity = Math.random() * 0.7 + 0.3;
      
      starsContainer.appendChild(star);
    }
  }
  
  // æ·»åŠ å…‰ç…§
  function addLights() {
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    // ä¸»æ–¹å‘å…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.left = -10;
      directionalLight.shadow.camera.right = 10;
      directionalLight.shadow.camera.top = 10;
      directionalLight.shadow.camera.bottom = -10;
    scene.add(directionalLight);
    
    // è›‹ç³•å‘¨å›´çš„ç‚¹å…‰æº
    const pointLight = new THREE.PointLight(0xffaa88, 0.5, 100);
    pointLight.position.set(0, 10, 5);
    scene.add(pointLight);
    
    // èœ¡çƒ›å‘¨å›´çš„ç‚¹å…‰æº
    const candleLight = new THREE.PointLight(0xffaa00, 0.3, 20);
    candleLight.position.set(0, 8, 0);
    scene.add(candleLight);
  }
  
  // åˆ›å»ºè›‹ç³•
  function createCake() {
    cakeGroup = new THREE.Group();
    scene.add(cakeGroup);
    
    // è›‹ç³•ä½ç½®
    cakeGroup.position.y = 1;
    
    // åˆ›å»ºç²¾ç¾çš„è›‹ç³•ç›˜
    const plateGeometry = new THREE.CylinderGeometry(6, 6.2, 0.4, 32);
    const plateMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xf8f8f8,
      metalness: 0.6,
      roughness: 0.1
    });
    const plate = new THREE.Mesh(plateGeometry, plateMaterial);
    plate.position.y = 0;
    plate.receiveShadow = true;
    cakeGroup.add(plate);
    
    // ç›˜å­é‡‘è‰²è£…é¥°èŠ±çº¹
    const patternGeometry = new THREE.TorusGeometry(6.3, 0.08, 8, 48);
    const patternMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xffd700,
      metalness: 0.9,
      roughness: 0.1
    });
    const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
    pattern.position.y = 0.2;
    pattern.rotation.x = Math.PI / 2;
    cakeGroup.add(pattern);
    
    // ç›˜å­å†…è¾¹ç¼˜è£…é¥°
    const innerEdgeGeometry = new THREE.TorusGeometry(5.8, 0.05, 8, 48);
    const innerEdgeMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xffd700,
      metalness: 0.9,
      roughness: 0.1
    });
    const innerEdge = new THREE.Mesh(innerEdgeGeometry, innerEdgeMaterial);
    innerEdge.position.y = 0.1;
    innerEdge.rotation.x = Math.PI / 2;
    cakeGroup.add(innerEdge);
    
    // åˆ›å»º6å±‚æ¸å˜è›‹ç³•
    const layers = [
      { radius: 5.2, height: 1.6, y: 0.2, color: 0xffb6c1, decoration: 0xff9999 },
      { radius: 4.4, height: 1.5, y: 1.8, color: 0xff99aa, decoration: 0xff8888 },
      { radius: 3.6, height: 1.4, y: 3.3, color: 0xff7f94, decoration: 0xff7777 },
      { radius: 2.8, height: 1.3, y: 4.7, color: 0xff6680, decoration: 0xff6666 },
      { radius: 2.0, height: 1.2, y: 6.0, color: 0xff4d6d, decoration: 0xff5555 },
      { radius: 1.4, height: 1.1, y: 7.2, color: 0xff3366, decoration: 0xff4444 }
    ];
    
    // åœ¨æ¯å±‚è›‹ç³•ä¸Šæ·»åŠ ç”Ÿæ—¥ç¥ç¦æ–‡å­—
    const birthdayText = "ğŸ‚ç”Ÿæ—¥å¿«ä¹ğŸ‚";
    const textColors = [0xffd700, 0xffffff, 0xffd700, 0xffffff, 0xffd700, 0xffffff];
    
    layers.forEach((layer, index) => {
      // è›‹ç³•ä¸»ä½“
      const geometry = new THREE.CylinderGeometry(layer.radius, layer.radius, layer.height, 32);
      const material = new THREE.MeshStandardMaterial({ 
        color: layer.color,
        roughness: 0.4,
        metalness: 0.2
      });
      const layerMesh = new THREE.Mesh(geometry, material);
      layerMesh.position.y = layer.y;
      layerMesh.castShadow = true;
      layerMesh.receiveShadow = true;
      cakeGroup.add(layerMesh);
      
      // æ·»åŠ è›‹ç³•çº¹ç†ç»†èŠ‚
      addCakeTexture(layerMesh, layer.radius, layer.height, layer.y, layer.color);
      
      // åœ¨æ¯å±‚è›‹ç³•è¡¨é¢åˆ›å»ºæ–‡å­—
      createTextOnCakeLayer(layer.radius, layer.height, layer.y, birthdayText, textColors[index]);
      
      // æ¯å±‚é¡¶éƒ¨çš„å¥¶æ²¹è£…é¥°
      const creamGeometry = new THREE.TorusGeometry(layer.radius, 0.15, 12, 48);
      const creamMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        roughness: 0.1,
        metalness: 0.1
      });
      const cream = new THREE.Mesh(creamGeometry, creamMaterial);
      cream.position.y = layer.y + layer.height / 2;
      cream.rotation.x = Math.PI / 2;
      cakeGroup.add(cream);
      
    
      
      // åœ¨å¥¶æ²¹ä¸Šæ·»åŠ å½©è‰²ç³–ç 
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const sugarGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x00ffff];
        const sugarMaterial = new THREE.MeshStandardMaterial({ 
          color: colors[Math.floor(Math.random() * colors.length)],
          roughness: 0.3,
          metalness: 0.2
        });
        const sugar = new THREE.Mesh(sugarGeometry, sugarMaterial);
        sugar.position.set(
          Math.cos(angle) * (layer.radius - 0.1),
          layer.y + layer.height / 2 + 0.12,
          Math.sin(angle) * (layer.radius - 0.1)
        );
        cakeGroup.add(sugar);
      }
      
      // åœ¨è›‹ç³•ä¾§é¢æ·»åŠ è£…é¥°æ¡çº¹
      addLayerStripes(layer.radius, layer.height, layer.y, layer.decoration);
    });
    
    // åˆ›å»ºè›‹ç³•é¡¶å±‚ï¼ˆåŠçƒå½¢ï¼‰
    const topGeometry = new THREE.SphereGeometry(1.6, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2);
    const topMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xff3366,
      roughness: 0.3,
      metalness: 0.1
    });
    const top = new THREE.Mesh(topGeometry, topMaterial);
    top.position.y = 7.8;
    top.rotation.x = Math.PI;
    cakeGroup.add(top);
    
    // é¡¶å±‚æ·»åŠ å¥¶æ²¹èŠ±è¾¹
    const topCreamGeometry = new THREE.TorusGeometry(1.7, 0.12, 8, 32);
    const topCreamMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xffffff,
      roughness: 0.1
    });
    const topCream = new THREE.Mesh(topCreamGeometry, topCreamMaterial);
    topCream.position.y = 7.85;
    topCream.rotation.x = Math.PI / 2;
    cakeGroup.add(topCream);
    
    // åœ¨è›‹ç³•é¡¶å±‚æ·»åŠ æ–‡å­—
    createTextOnTop(top.position.y + 0.4, birthdayText);
    
    // åœ¨é¡¶å±‚æ·»åŠ å¤§ç³–ç 
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const pearlGeometry = new THREE.SphereGeometry(0.2, 16, 16);
      const colors = [0xffd700, 0xffffff, 0xff4444, 0x00ff00];
      const pearlMaterial = new THREE.MeshStandardMaterial({ 
        color: colors[i % colors.length],
        roughness: 0.2,
        metalness: 0.8
      });
      const pearl = new THREE.Mesh(pearlGeometry, pearlMaterial);
      pearl.position.set(
        Math.cos(angle) * 1.4,
        7.9,
        Math.sin(angle) * 1.4
      );
      cakeGroup.add(pearl);
    }
    
    // åˆ›å»ºèœ¡çƒ›
    createCandles();
  }
  
  // æ·»åŠ è›‹ç³•çº¹ç†ç»†èŠ‚
  function addCakeTexture(layerMesh, radius, height, yPos, baseColor) {
    const textureGroup = new THREE.Group();
    
    // æ·»åŠ éšæœºåˆ†å¸ƒçš„è£…é¥°ç‚¹
    for (let i = 0; i < 30; i++) {
      const decorationGeometry = new THREE.SphereGeometry(0.05, 6, 6);
      const decorationMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        roughness: 0.4
      });
      const decoration = new THREE.Mesh(decorationGeometry, decorationMaterial);
      
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * (radius - 0.3);
      decoration.position.set(
        Math.cos(angle) * distance,
        (Math.random() - 0.5) * height * 0.8,
        Math.sin(angle) * distance
      );
      
      layerMesh.add(decoration);
    }
  }
  

  
  // æ·»åŠ è›‹ç³•å±‚è£…é¥°æ¡çº¹
  function addLayerStripes(radius, height, yPos, stripeColor) {
    const stripeGroup = new THREE.Group();
    
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      
      const stripeGeometry = new THREE.BoxGeometry(0.1, height * 0.7, 0.1);
      const stripeMaterial = new THREE.MeshStandardMaterial({ 
        color: stripeColor,
        roughness: 0.5,
        metalness: 0.2
      });
      
      const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
      
      const x = Math.cos(angle) * (radius - 0.15);
      const z = Math.sin(angle) * (radius - 0.15);
      
      stripe.position.set(x, yPos, z);
      stripe.lookAt(0, yPos, 0);
      
      stripeGroup.add(stripe);
    }
    
    cakeGroup.add(stripeGroup);
  }
  
  // åœ¨æ¯å±‚è›‹ç³•è¡¨é¢åˆ›å»ºæ–‡å­—
  function createTextOnCakeLayer(radius, height, yPos, text, textColor) {
    const textGroup = new THREE.Group();
    const charCount = text.length;
    const angleStep = (Math.PI * 2) / charCount;
    const textSize = 0.4;
    
    for (let i = 0; i < charCount; i++) {
      const char = text[i];
      const angle = i * angleStep;
      
      const geometry = new THREE.BoxGeometry(textSize, textSize * 0.7, 0.1);
      const material = new THREE.MeshPhongMaterial({ 
        color: textColor,
        specular: 0xffffff,
        shininess: 100,
        emissive: textColor,
        emissiveIntensity: 0.2
      });
      const charMesh = new THREE.Mesh(geometry, material);
      
      const x = Math.cos(angle) * (radius - 0.3);
      const z = Math.sin(angle) * (radius - 0.3);
      charMesh.position.set(x, yPos, z);
      
      charMesh.lookAt(x * 2, yPos, z * 2);
      
      addCharDecoration(charMesh, char, textColor);
      
      textGroup.add(charMesh);
      birthdayTextMeshes.push(charMesh);
    }
    
    cakeGroup.add(textGroup);
  }
  
  // åœ¨è›‹ç³•é¡¶å±‚åˆ›å»ºæ–‡å­—
  function createTextOnTop(yPos, text) {
    const textGroup = new THREE.Group();
    const charCount = text.length;
    const angleStep = (Math.PI * 2) / charCount;
    const textSize = 0.3;
    const radius = 1.5;
    
    for (let i = 0; i < charCount; i++) {
      const char = text[i];
      const angle = i * angleStep;
      
      const geometry = new THREE.CylinderGeometry(textSize/2, textSize/2, textSize, 6);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0xffd700,
        specular: 0xffffff,
        shininess: 100,
        emissive: 0xffd700,
        emissiveIntensity: 0.5
      });
      const charMesh = new THREE.Mesh(geometry, material);
      
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      charMesh.position.set(x, yPos, z);
      
      charMesh.rotation.x = Math.PI / 6;
      charMesh.rotation.y = angle;
      
      addCharDecoration(charMesh, char, 0xffd700);
      
      textGroup.add(charMesh);
      birthdayTextMeshes.push(charMesh);
    }
    
    cakeGroup.add(textGroup);
  }
  
  // æ·»åŠ å­—ç¬¦è£…é¥°
  function addCharDecoration(charMesh, char, baseColor) {
    const decorationCount = Math.floor(Math.random() * 3) + 2;
    
    for (let i = 0; i < decorationCount; i++) {
      const geometry = new THREE.SphereGeometry(0.05, 6, 6);
      const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff];
      const material = new THREE.MeshPhongMaterial({ 
        color: colors[Math.floor(Math.random() * colors.length)],
        emissive: baseColor,
        emissiveIntensity: 0.2
      });
      const decoration = new THREE.Mesh(geometry, material);
      
      decoration.position.set(
        (Math.random() - 0.5) * 0.4,
        (Math.random() - 0.5) * 0.4 + 0.2,
        (Math.random() - 0.5) * 0.4
      );
      
      charMesh.add(decoration);
    }
  }
  
  // åˆ›å»ºèœ¡çƒ›
  function createCandles() {
    const candleCount = 24;
    
    for (let i = 0; i < candleCount; i++) {
      const angle = (i / candleCount) * Math.PI * 2;
      const radius = 1.8;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      
      const candleGroup = new THREE.Group();
      
      // èœ¡çƒ›ä¸»ä½“
      const candleGeometry = new THREE.CylinderGeometry(0.12, 0.14, 1.4, 12);
      const candleMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.1
      });
      const candle = new THREE.Mesh(candleGeometry, candleMaterial);
      candle.position.y = 0.7;
      candleGroup.add(candle);
      
      // æ·»åŠ èœ¡çƒ›æ¡çº¹
      const candleStripes = new THREE.Group();
      for (let j = 0; j < 3; j++) {
        const stripeGeometry = new THREE.TorusGeometry(0.12, 0.02, 8, 12);
        const stripeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffd700,
          roughness: 0.3,
          metalness: 0.7
        });
        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
        stripe.position.y = (j - 1) * 0.4;
        candleStripes.add(stripe);
      }
      candleGroup.add(candleStripes);
      
      // çƒ›èŠ¯
      const wickGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.25, 6);
      const wickMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x111111,
        roughness: 0.8
      });
      const wick = new THREE.Mesh(wickGeometry, wickMaterial);
      wick.position.y = 1.4;
      candleGroup.add(wick);
      
      // çƒ›ç„°ç²’å­ç³»ç»Ÿ
      const flameGroup = new THREE.Group();
      
      // ä¸»ç«ç„°
      const flameMaterial = new THREE.MeshBasicMaterial({
        map: flameTextures[0],
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const flameGeometry = new THREE.ConeGeometry(0.15, 0.7, 8);
      flameGeometry.translate(0, 0.35, 0);
      const flame = new THREE.Mesh(flameGeometry, flameMaterial);
      flame.position.y = 1.5;
      flameGroup.add(flame);
      
      // å†…ç„°
      const innerFlameMaterial = new THREE.MeshBasicMaterial({
        map: flameTextures[1],
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const innerFlame = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.5, 8), innerFlameMaterial);
      innerFlame.position.y = 1.5;
      flameGroup.add(innerFlame);
      
      // çƒ›å…‰
      const flameLight = new THREE.PointLight(0xffaa00, 1.5, 4);
      flameLight.position.y = 1.5;
      flameGroup.add(flameLight);
      
      // çƒ›å…‰é—ªçƒ
      const flickerLight = new THREE.PointLight(0xff6600, 0.8, 3);
      flickerLight.position.y = 1.7;
      flameGroup.add(flickerLight);
      
      // èœ¡çƒ›åº•åº§
      const baseGeometry = new THREE.CylinderGeometry(0.16, 0.12, 0.2, 12);
      const baseMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffd700,
        roughness: 0.3,
        metalness: 0.8
      });
      const candleBase = new THREE.Mesh(baseGeometry, baseMaterial);
      candleBase.position.y = 0;
      candleGroup.add(candleBase);
      
      candleGroup.add(flameGroup);
      
      flames.push({
        flameGroup: flameGroup,
        flame: flame,
        innerFlame: innerFlame,
        light: flameLight,
        flickerLight: flickerLight,
        lit: true,
        flameIndex: 0,
        timeOffset: Math.random() * 100,
        smokeTime: 0
      });
      
      candleGroup.position.set(x, 7.9, z);
      cakeGroup.add(candleGroup);
    }
  }
  
  // åˆ›å»ºçƒŸé›¾ç²’å­
  function createSmokeParticle(x, y, z) {
    const smokeGeometry = new THREE.SphereGeometry(0.02, 8, 8);
    const smokeMaterial = new THREE.MeshBasicMaterial({
      color: 0x666666,
      transparent: true,
      opacity: 0.6
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smoke.position.set(x, y, z);
    smoke.userData = {
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 0.02,
        Math.random() * 0.05 + 0.02,
        (Math.random() - 0.5) * 0.02
      ),
      life: 1.0,
      scale: Math.random() * 0.5 + 0.5
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
    return smoke;
  }
  
  // äº‹ä»¶ç›‘å¬
  function setupEventListeners() {
    // é‡æ–°ç‚¹ç‡ƒæŒ‰é’®
    document.getElementById("relightBtn").addEventListener("click", relightCandles);
    
    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener("resize", function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // é”®ç›˜å¿«æ·é”®
    document.addEventListener("keydown", function(e) {
      if (e.code === 'Space') {
        e.preventDefault();
        blowOutCandles();
      } else if (e.key === 'r' || e.key === 'R') {
        relightCandles();
      } 
    });
    
    // ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶
    if (isMobile) {
      setupMobileControls();
    } else {
      // æ¡Œé¢ç«¯é¼ æ ‡æ§åˆ¶
      setupDesktopControls();
    }
  }
  
 
  // è®¾ç½®æ¡Œé¢ç«¯æ§åˆ¶
  function setupDesktopControls() {
    let isMouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    renderer.domElement.addEventListener('mousedown', function(e) {
      isMouseDown = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    
    document.addEventListener('mouseup', function() {
      isMouseDown = false;
    });
    
    document.addEventListener('mousemove', function(e) {
      if (!isMouseDown) return;
      
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      
      cakeGroup.rotation.y += deltaX * 0.01;
      cakeGroup.rotation.x += deltaY * 0.005;
      cakeGroup.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cakeGroup.rotation.x));
      
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    
    // é¼ æ ‡æ»šè½®ç¼©æ”¾
    renderer.domElement.addEventListener('wheel', function(e) {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.01;
      camera.position.z = Math.max(5, Math.min(30, camera.position.z));
    });
  }
  
  // è®¾ç½®ç§»åŠ¨ç«¯æ§åˆ¶
  function setupMobileControls() {
    // æ˜¾ç¤ºè§¦æ‘¸æ§åˆ¶
    document.getElementById('joystick').style.display = 'block';
    document.getElementById('touchZoom').style.display = 'block';
    
    // æ‘‡æ†æ§åˆ¶
    const joystick = document.getElementById('joystick');
    const joystickBase = joystick.querySelector('.touch-joystick-base');
    const joystickHandle = joystick.querySelector('.touch-joystick-handle');
    
    joystick.addEventListener('touchstart', function(e) {
      e.preventDefault();
      isTouchJoystickActive = true;
      const rect = joystick.getBoundingClientRect();
      joystickStartPos = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
      updateJoystick(e.touches[0]);
    });
    
    document.addEventListener('touchmove', function(e) {
      if (isTouchJoystickActive) {
        e.preventDefault();
        updateJoystick(e.touches[0]);
      }
    });
    
    document.addEventListener('touchend', function(e) {
      if (isTouchJoystickActive) {
        isTouchJoystickActive = false;
        joystickCurrentPos = { x: 0, y: 0 };
        joystickHandle.style.transform = 'translate(-50%, -50%)';
        cakeRotationSpeed = { x: 0, y: 0 };
      }
    });
    
    function updateJoystick(touch) {
      const deltaX = touch.clientX - joystickStartPos.x;
      const deltaY = touch.clientY - joystickStartPos.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = 50;
      
      if (distance > maxDistance) {
        const angle = Math.atan2(deltaY, deltaX);
        joystickCurrentPos.x = Math.cos(angle) * maxDistance;
        joystickCurrentPos.y = Math.sin(angle) * maxDistance;
      } else {
        joystickCurrentPos.x = deltaX;
        joystickCurrentPos.y = deltaY;
      }
      
      joystickHandle.style.transform = `translate(calc(-50% + ${joystickCurrentPos.x}px), calc(-50% + ${joystickCurrentPos.y}px))`;
      
      cakeRotationSpeed = {
        x: -joystickCurrentPos.y / maxDistance * 0.05,
        y: -joystickCurrentPos.x / maxDistance * 0.05
      };
    }
    
    // ç¼©æ”¾æŒ‰é’®
    document.getElementById('zoomIn').addEventListener('touchstart', function(e) {
      e.preventDefault();
      camera.position.z -= 1;
      camera.position.z = Math.max(5, Math.min(30, camera.position.z));
    });
    
    document.getElementById('zoomOut').addEventListener('touchstart', function(e) {
      e.preventDefault();
      camera.position.z += 1;
      camera.position.z = Math.max(5, Math.min(30, camera.position.z));
    });
    
    // åŒæŒ‡ç¼©æ”¾
    let initialDistance = 0;
    let initialZoom = 15;
    
    document.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        initialZoom = camera.position.z;
      }
    });
    
    document.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2 && !isTouchJoystickActive) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        
        const scale = initialDistance / currentDistance;
        camera.position.z = initialZoom * scale;
        camera.position.z = Math.max(5, Math.min(30, camera.position.z));
      }
    });
  }
  
  // è¯·æ±‚éº¦å…‹é£æƒé™
  function requestMicrophonePermission() {
    if (micPermissionRequested) return;
    micPermissionRequested = true;
    
    // æ˜¾ç¤ºæƒé™æç¤º
    document.getElementById('permissionPrompt').style.display = 'flex';
    
    // å…è®¸æŒ‰é’®
    document.getElementById('allowMic').addEventListener('click', function() {
      document.getElementById('permissionPrompt').style.display = 'none';
      startMicrophone();
    });
    
    // 3ç§’åè‡ªåŠ¨éšè—æç¤º
    setTimeout(() => {
      document.getElementById('permissionPrompt').style.display = 'none';
      // å³ä½¿ä¸æˆæƒä¹Ÿå°è¯•å¯åŠ¨éº¦å…‹é£
      setTimeout(startMicrophone, 1000);
    }, 3000);
  }
  
  // å¼€å§‹éº¦å…‹é£
  async function startMicrophone() {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        updateMicStatus("âš ï¸ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£åŠŸèƒ½");
        return;
      }
      
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false
        } 
      });
      
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      microphone = audioContext.createMediaStreamSource(stream);
      microphone.connect(analyser);
      
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);
      
      isMicActive = true;
      updateMicStatus("ğŸ¤ éº¦å…‹é£å·²å°±ç»ªï¼Œè¯·å¹æ°”");
      
      startAudioAnalysis();
      
    } catch (err) {
      console.log('éº¦å…‹é£è®¾ç½®:', err.name);
      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
        updateMicStatus("ğŸ¤ ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®åå¹æ°”");
        setupTapToEnableMic();
      } else {
        updateMicStatus("ğŸ‚ å¯è§¦æ‘¸æ—‹è½¬è›‹ç³•è§‚çœ‹");
      }
    }
  }
  
  // è®¾ç½®ç‚¹å‡»å¯ç”¨éº¦å…‹é£
  function setupTapToEnableMic() {
    let tapCount = 0;
    const tapHandler = function() {
      tapCount++;
      if (tapCount === 1) {
        updateMicStatus("ğŸ¤ å†ç‚¹ä¸€æ¬¡å¯ç”¨éº¦å…‹é£");
        setTimeout(() => {
          if (tapCount === 1) {
            updateMicStatus("ğŸ¤ ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®åå¹æ°”");
            tapCount = 0;
          }
        }, 2000);
      } else if (tapCount === 2) {
        startMicrophone();
        document.removeEventListener('click', tapHandler);
        document.removeEventListener('touchstart', tapHandler);
      }
    };
    
    document.addEventListener('click', tapHandler);
    document.addEventListener('touchstart', tapHandler);
  }
  
  // æ›´æ–°éº¦å…‹é£çŠ¶æ€
  function updateMicStatus(text) {
    const micStatus = document.getElementById('micStatus');
    micStatus.textContent = text;
    
    micStatus.classList.remove('auto-hide');
    void micStatus.offsetWidth;
    micStatus.classList.add('auto-hide');
  }
  
  // å¼€å§‹éŸ³é¢‘åˆ†æ
  function startAudioAnalysis() {
    if (!isMicActive) return;
    
    function analyzeAudio() {
      if (!analyser || !dataArray) return;
      
      analyser.getByteFrequencyData(dataArray);
      
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length;
      
      let lowFreqSum = 0;
      const lowFreqCount = Math.floor(dataArray.length * 0.3);
      for (let i = 0; i < lowFreqCount; i++) {
        lowFreqSum += dataArray[i];
      }
      const lowFreqAverage = lowFreqSum / lowFreqCount;
      
      const currentTime = Date.now();
      const timeSinceLastBlow = currentTime - lastBlowTime;
      
      if (lowFreqAverage > 50 && average > 20 && timeSinceLastBlow > 2000) {
        blowIntensity += 0.3;
        
        if (blowIntensity > 0.5) {
          document.getElementById('micStatus').textContent = "ğŸ’¨ æ£€æµ‹åˆ°å¹æ°”ï¼ç»§ç»­å¹...";
          document.getElementById('micStatus').classList.add('blowing');
          
          // å¹æ°”æ—¶ç«ç„°æŠ–åŠ¨
          flames.forEach(candle => {
            if (candle.lit) {
              const intensity = Math.min(1, blowIntensity);
              candle.flameGroup.position.x = (Math.random() - 0.5) * 0.1 * intensity;
              candle.flameGroup.position.z = (Math.random() - 0.5) * 0.1 * intensity;
            }
          });
        }
        
        if (blowIntensity > 1.5) {
          blowIntensity = 0;
          lastBlowTime = currentTime;
          blowOutCandles();
          
          document.getElementById('micStatus').textContent = "ğŸ‚ ç”Ÿæ—¥å¿«ä¹ï¼";
          document.getElementById('micStatus').classList.remove('blowing');
          
          setTimeout(() => {
            if (isMicActive) {
              document.getElementById('micStatus').textContent = "ğŸ¤ éº¦å…‹é£å·²å°±ç»ª";
            }
          }, 3000);
        }
      } else {
        blowIntensity = Math.max(0, blowIntensity - 0.1);
        if (timeSinceLastBlow > 1000 && isMicActive && !document.getElementById('micStatus').classList.contains('blowing')) {
          document.getElementById('micStatus').classList.remove('blowing');
        }
      }
      
      requestAnimationFrame(analyzeAudio);
    }
    
    analyzeAudio();
  }
  
  // å¹ç­èœ¡çƒ›
  function blowOutCandles() {
    let allLit = true;
    
    flames.forEach(function(candle) {
      if (candle.lit) {
        candle.lit = false;
        candle.flameGroup.visible = false;
        candle.light.visible = false;
        candle.flickerLight.visible = false;
        allLit = false;
        
        // åˆ›å»ºå¹ç­æ—¶çš„çƒŸé›¾
        for (let i = 0; i < 5; i++) {
          const x = candle.flameGroup.position.x + candle.flameGroup.parent.position.x;
          const y = candle.flameGroup.position.y + candle.flameGroup.parent.position.y;
          const z = candle.flameGroup.position.z + candle.flameGroup.parent.position.z;
          createSmokeParticle(x, y, z);
        }
      }
    });
    
    if (!allLit) {
      showBirthdayMessage();
      startConfetti();
      
      birthdayTextMeshes.forEach(mesh => {
        if (mesh.material.emissiveIntensity) {
          mesh.material.emissiveIntensity = 0.8;
        }
      });
      
      playBlowSound();
    }
  }
  
// æ’­æ”¾å¹èœ¡çƒ›å£°éŸ³ - ä½¿ç”¨é¢„å½•éŸ³æ•ˆ
function playBlowSound() {
  try {
    const blowSound = document.getElementById('blowSound');
    if (blowSound) {
      blowSound.currentTime = 0; // é‡ç½®æ’­æ”¾ä½ç½®
      blowSound.volume = 0.7; // è®¾ç½®éŸ³é‡
      blowSound.play().catch(e => {
        console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
        // å¦‚æœé¢„å½•éŸ³æ•ˆå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨åˆæˆéŸ³æ•ˆ
        playSyntheticBlowSound();
      });
    } else {
      // å¦‚æœæ‰¾ä¸åˆ°éŸ³é¢‘å…ƒç´ ï¼Œä½¿ç”¨å¤‡ç”¨åˆæˆéŸ³æ•ˆ
      playSyntheticBlowSound();
    }
  } catch (err) {
    console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', err);
    // å‡ºé”™æ—¶ä½¿ç”¨å¤‡ç”¨åˆæˆéŸ³æ•ˆ
    playSyntheticBlowSound();
  }
}

// å¤‡ç”¨åˆæˆéŸ³æ•ˆï¼ˆå½“é¢„å½•éŸ³æ•ˆä¸å¯ç”¨æ—¶ä½¿ç”¨ï¼‰
function playSyntheticBlowSound() {
  if (!audioContext) return;
  
  try {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(120, audioContext.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(60, audioContext.currentTime + 0.4);
    
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 0.5);
  } catch (err) {
    console.log('åˆæˆéŸ³æ•ˆä¹Ÿå¤±è´¥äº†:', err);
  }
}
  
  // é‡æ–°ç‚¹ç‡ƒèœ¡çƒ›
  function relightCandles() {
    flames.forEach(function(candle) {
      candle.lit = true;
      candle.flameGroup.visible = true;
      candle.light.visible = true;
      candle.flickerLight.visible = true;
      
      // é‡ç½®ç«ç„°ä½ç½®
      candle.flameGroup.position.set(0, 0, 0);
    });
    
    document.getElementById("birthdayMessage").style.opacity = 0;
    
    birthdayTextMeshes.forEach(mesh => {
      if (mesh.material.emissiveIntensity) {
        mesh.material.emissiveIntensity = 0.2;
      }
    });
    
    if (isMicActive) {
      document.getElementById('micStatus').textContent = "ğŸ¤ éº¦å…‹é£å·²å°±ç»ª";
    }
  }
  
  // æ˜¾ç¤ºç”Ÿæ—¥æ¶ˆæ¯
  function showBirthdayMessage() {
    const message = document.getElementById("birthdayMessage");
    message.textContent = "ğŸ‚æ¨æ€è•Šï¼Œç”Ÿæ—¥å¿«ä¹ğŸ‚";
    message.style.opacity = 1;
    
    setTimeout(function() {
      message.style.opacity = 0;
    }, 5000);
  }
  
  // å¼€å§‹äº”å½©çº¸å±‘æ•ˆæœ
  function startConfetti() {
    if (confettiActive) return;
    
    confettiActive = true;
    const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
    
    for (let i = 0; i < 100; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.top = '-20px';
      confetti.style.transform = 'rotate(' + (Math.random() * 360) + 'deg)';
      
      const size = Math.random() * 10 + 5;
      confetti.style.width = size + 'px';
      confetti.style.height = size + 'px';
      
      const animation = confetti.animate([
        { 
          transform: 'translate(0, 0) rotate(0deg)',
          opacity: 1 
        },
        { 
          transform: 'translate(' + (Math.random() * 200 - 100) + 'px, 100vh) rotate(' + (Math.random() * 720) + 'deg)',
          opacity: 0 
        }
      ], {
        duration: Math.random() * 3000 + 2000,
        easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)'
      });
      
      document.body.appendChild(confetti);
      confettiParticles.push({ element: confetti, animation: animation });
      
      animation.onfinish = function() {
        confetti.remove();
      };
    }
    
    setTimeout(function() {
      stopConfetti();
    }, 3000);
  }
  
  // åœæ­¢äº”å½©çº¸å±‘
  function stopConfetti() {
    confettiActive = false;
    confettiParticles.forEach(function(particle) {
      if (particle.animation.playState !== 'finished') {
        particle.animation.finish();
      }
    });
    confettiParticles = [];
  }
  
  // æ›´æ–°ç«ç„°
  function updateFlames(deltaTime) {
    flames.forEach(candle => {
      if (candle.lit) {
        const time = Date.now() * 0.001 + candle.timeOffset;
        
        // ç«ç„°åŠ¨ç”»
        const flickerX = Math.sin(time * 15) * 0.05;
        const flickerY = Math.sin(time * 12 + 1) * 0.05;
        const flickerZ = Math.cos(time * 13 + 2) * 0.05;
        
        candle.flameGroup.position.set(flickerX, flickerY, flickerZ);
        
        // ç«ç„°ç¼©æ”¾åŠ¨ç”»
        const baseScale = 0.8 + Math.sin(time * 8) * 0.2;
        const innerScale = 0.7 + Math.sin(time * 10 + 1) * 0.3;
        
        candle.flame.scale.set(baseScale, baseScale, 1);
        candle.innerFlame.scale.set(innerScale, innerScale, 1);
        
        // ç«ç„°æ—‹è½¬åŠ¨ç”»
        candle.flame.rotation.z = Math.sin(time * 5) * 0.2;
        candle.innerFlame.rotation.z = Math.cos(time * 6) * 0.3;
        
        // ç«ç„°çº¹ç†åŠ¨ç”»
        const frame = Math.floor(time * 10) % flameTextures.length;
        if (frame !== candle.flameIndex) {
          candle.flame.material.map = flameTextures[frame];
          candle.flame.material.needsUpdate = true;
          candle.innerFlame.material.map = flameTextures[(frame + 1) % flameTextures.length];
          candle.innerFlame.material.needsUpdate = true;
          candle.flameIndex = frame;
        }
        
        // çƒ›å…‰å¼ºåº¦åŠ¨ç”»
        const lightIntensity = 1.2 + Math.sin(time * 8) * 0.3;
        const flickerIntensity = 0.6 + Math.sin(time * 12 + 2) * 0.4;
        
        candle.light.intensity = lightIntensity;
        candle.flickerLight.intensity = flickerIntensity;
        
        // çƒŸé›¾ç²’å­
        candle.smokeTime += deltaTime;
        if (candle.smokeTime > 0.5 && Math.random() > 0.7) {
          const x = candle.flameGroup.position.x + candle.flameGroup.parent.position.x;
          const y = candle.flameGroup.position.y + candle.flameGroup.parent.position.y + 0.2;
          const z = candle.flameGroup.position.z + candle.flameGroup.parent.position.z;
          createSmokeParticle(x, y, z);
          candle.smokeTime = 0;
        }
      }
    });
    
    // æ›´æ–°çƒŸé›¾ç²’å­
    for (let i = smokeParticles.length - 1; i >= 0; i--) {
      const smoke = smokeParticles[i];
      const data = smoke.userData;
      
      data.life -= deltaTime * 0.5;
      smoke.position.x += data.velocity.x;
      smoke.position.y += data.velocity.y;
      smoke.position.z += data.velocity.z;
      smoke.scale.setScalar(data.scale * (1 + deltaTime * 2));
      smoke.material.opacity = data.life * 0.4;
      
      // éšæœºæ—‹è½¬
      smoke.rotation.x += deltaTime * 0.5;
      smoke.rotation.y += deltaTime * 0.3;
      
      if (data.life <= 0) {
        scene.remove(smoke);
        smokeParticles.splice(i, 1);
      }
    }
  }
  
  // åŠ¨ç”»å¾ªç¯
  function animate() {
    requestAnimationFrame(animate);
    
    const deltaTime = clock.getDelta();
    const time = Date.now() * 0.001;
    
    // ç§»åŠ¨ç«¯æ‘‡æ†æ§åˆ¶æ—‹è½¬
    if (isMobile && isTouchJoystickActive) {
      cakeGroup.rotation.x += cakeRotationSpeed.x;
      cakeGroup.rotation.y += cakeRotationSpeed.y;
      cakeGroup.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cakeGroup.rotation.x));
    }
    
    // æ›´æ–°ç«ç„°
    updateFlames(deltaTime);
    
    // æ–‡å­—å‘å…‰åŠ¨ç”»
    birthdayTextMeshes.forEach(mesh => {
      if (mesh.material.emissiveIntensity) {
        const pulse = 0.1 + Math.sin(time * 2 + mesh.position.x) * 0.1;
        mesh.material.emissiveIntensity = Math.max(0.1, mesh.material.emissiveIntensity + pulse * 0.01);
        
        // è½»å¾®æµ®åŠ¨æ•ˆæœ
        mesh.position.y += Math.sin(time + mesh.position.x) * 0.001;
      }
    });
    
    // ç³–ç è½»å¾®æ—‹è½¬
    cakeGroup.children.forEach(child => {
      if (child.geometry && child.geometry.type === 'SphereGeometry') {
        child.rotation.y += deltaTime * 0.5;
      }
    });
    
    // è½»å¾®è‡ªåŠ¨æ—‹è½¬
    if (!isTouchJoystickActive) {
      cakeGroup.rotation.y += deltaTime * 0.1;
    }
    
    renderer.render(scene, camera);
  }
  
  // æ£€æŸ¥å¹¶å¯åŠ¨
  if (typeof THREE !== 'undefined') {
    setTimeout(init, 100);
  } else {
    document.getElementById('loading').textContent = 'åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢';
  }
});
</script>

</body>

</html>

